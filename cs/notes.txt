// *********** GLOBAL *************
typedef struct _file_info
{
    int n;
    FILE *file;

} fileInfo;

fileInfo *info;

// ****************NLINEX************************
// The function NLINEX takes file as an argument*
// and return the number of lines in the file   *
// **********************************************

int _NLINX_Helper(FILE *file)
{
    int _number_of_lines = 0;
    char ch;
    while ((ch = fgetc(file)) != EOF)
    {
        if (ch == '\n')
        {
            _number_of_lines++;
        }
    }
    if (ftell(file) > 0)
    {
        _number_of_lines = _number_of_lines + 1;
        return _number_of_lines;
    }
    return _number_of_lines;
}

int _pre_check(char *buff, int size)
{
    int i = 0;
    int count = 0;
    while (i < size)
    {
        if (buff[i] == '\n')
        {
            count++;
        }
        i++;
    }
    return count;
}

int _atoi(char *str)
{
    int sign = 1, base = 0, i = 0, count = 0;
    while (str[i] == ' ')
    {
        i++;
    }
    if (str[i] == '-')
    {
        sign = 1 - 2 * (str[i++] == '-');
        count++;
    }
    while (str[i] >= '0' && str[i] <= '9')
    {
        if (base > __INT32_MAX__ / 10 || (base == __INT32_MAX__ / 10 && str[i] - '0' > 7))
        {
            if (sign == 1)
                return __INT32_MAX__;
            else
                return __INT32_MAX__;
        }
        base = 10 * base + (str[i++] - '0');
        count++;
    }
    if (count == strlen(str))
    {
        return base * sign;
    }
    else
    {
        return __INT32_MAX__;
    }
}

int _NLINEX()
{
    return info->n;
}

// ************READX***********************
// This function take index as an argument*
// return the line present at index.      *
// ****************************************
void _READX(int _index, char *buff)
{
    char ch;
    int count = 0;
    int total_line_count = info->n;
    bzero(buff, 1024);
    int idx = _index >= 0 ? _index : total_line_count + _index;
    while (count < idx && idx < total_line_count)
    {
        ch = fgetc(info->file);
        if (ch == '\n')
        {
            count++;
        }
    }
    if (idx >= 0 && idx < total_line_count)
    {
        int i = 0;
        while ((ch = fgetc(info->file)) != EOF)
        {
            buff[i] = ch;
            if (ch == '\n')
            {
                break;
            }
            i++;
        }
        rewind(info->file);
    }
    else
    {
        snprintf(buff, 1024, "%s", "Index out of range");
    }
}

// ***********INSERTX**************************
// This function take index and message      *
// and insert the message at specified index. *
// ********************************************

int _INSERTX(int _index, char *_msg, int _flag)
{
    if (_flag)
    {
        fseek(info->file, 0, SEEK_END);
        if (info->n == 0)
        {
            fputs(_msg, info->file);
            fputc('\n', info->file);
        }
        else
        {
            fputc('\n', info->file);
            fputs(_msg, info->file);
        }
        info->n = info->n + 1;
        rewind(info->file);
        return 1;
    }
    else
    {

        char ch;
        FILE *temp_file = tmpfile();
        int count = 0;
        int idx = _index >= 0 ? _index : info->n + _index;
        int _file_position;
        while (count < idx && idx < info->n)
        {
            ch = fgetc(info->file);
            if (ch == '\n')
            {
                count++;
            }
        }
        _file_position = ftell(info->file);
        if (idx >= 0 && idx < info->n)
        {
            while ((ch = fgetc(info->file)) != EOF)
            {
                fputc(ch, temp_file);
            }
            fseek(info->file, _file_position, SEEK_SET);
            fputs(_msg, info->file);
            fputc('\n', info->file);
            rewind(temp_file);
            while ((ch = fgetc(temp_file)) != EOF)
            {
                fputc(ch, info->file);
            }
            info->n = info->n + 1;
            rewind(info->file);
            fclose(temp_file);
            return 1;
        }
        else
        {
            fclose(temp_file);
            return 0;
        }
    }
}

// ***********INIT***************************
// ******************************************

void __init__(FILE *main_file)
{
    info = (fileInfo *)malloc(sizeof(fileInfo));
    info->n = _NLINX_Helper(main_file);
    info->file = main_file;
    rewind(info->file);
}
